## re 的使用和Python中的冲突
- 一篇很好的解释文章，[参照于此](https://blog.csdn.net/jinixin/article/details/56705284)
- 冲突的来源就是 \ ，因为它在 re 和 Python 中都有转义的意思，这里我们可以借助一个叫原始字符串的写法来进行处理，何为原始字符串，与普通字符串的区别？
```
print('abc\ndf\teg')
结果是：
abc
df	eg

print(r'abc\ndf\teg')
结果是：
'abc\ndf\teg'
```
可见，r使得原来Python中的转义字符失效，另一方面，在Python中，当转义字符后面跟着的不是有意义的转义时，如不是\n \t \d 等，而是随便的一个\h，那么它表示一个普通字符，它的实际组成是'\\h'，\\是Python中字符\的表示，在jupyter-notebook中直接输出，和print是有区别的，打印的时候，你看到的是Python格式所表达的，比如上面的例子中，print普通字符的时候，\n的地方就换行，\t的时候，就会用一个tab来间隔，在jupyter-notebook中：
```
txt = 'abc\ndf\teg\h'
txt
结果是：
'abc\ndf\teg\\h'
```
可见，当有意义的转义 \n \t，\就按照转移字符来处理，当没有意义，就作为字符\，但是为了将字符串中的\转义的功能失效，就要在转义一次，转义成为普通\字符。

- 问题来了，如果想要提取'34\89'中\之前的字符该如何处理？
```python
import re 
a = '34\89'
re.findall('(\d+)\\\\', a)
结果是：
['34']

re.findall(r'('\d+')\\', a)
结果是：
['34']
```
添加r之后，可以看作是将a转换成为原始字符串，那么在正则表达式中，只要将字符\转义出来即可，就是在字符\前添加转义字符。
- 关于re 中的\b
  - \b在正则表达式中是对单词边界进行界定，但是它在Python中有退格的意思，故有冲突，使用的时候，可加上r
  - 关于sklearn中，关于countVectorizer函数中的参数token_pattern='(?u)\\b\\w\\w+\\b',是对输入文本库进行界定的，我们输入文本库预处理称为一个列表，列表中的每一个元素都是一篇文章，每一篇文章右都讲过jieba分词分过，这样可以提取出每篇文章中组成词的字的个数大于等于2的词。
  - 这里正则表达式在\b前多了一个\，就是因为要对\b转义，也可以写成r'(?u)\b\w\w+\b'
  - (?u) 的意思是忽略大小写，对英文是有意义的，中文没有大小写一说.
